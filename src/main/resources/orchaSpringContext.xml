<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:stream="http://www.springframework.org/schema/integration/stream" xmlns:int="http://www.springframework.org/schema/integration" xmlns:int-mail="http://www.springframework.org/schema/integration/mail" xmlns:util="http://www.springframework.org/schema/util" xmlns:int-file="http://www.springframework.org/schema/integration/file" xmlns:int-stream="http://www.springframework.org/schema/integration/stream" xmlns:int-http="http://www.springframework.org/schema/integration/http" xmlns:int-groovy="http://www.springframework.org/schema/integration/groovy" xmlns:context="http://www.springframework.org/schema/context" xmlns:task="http://www.springframework.org/schema/task" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:int-jdbc="http://www.springframework.org/schema/integration/jdbc" xmlns:int-script="http://www.springframework.org/schema/integration/scripting" xmlns:int-event="http://www.springframework.org/schema/integration/event" xmlns:int-amqp="http://www.springframework.org/schema/integration/amqp" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration-4.3.xsd http://www.springframework.org/schema/integration/mail http://www.springframework.org/schema/integration/mail/spring-integration-mail-4.3.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file-4.3.xsd http://www.springframework.org/schema/integration/stream http://www.springframework.org/schema/integration/stream/spring-integration-stream-4.3.xsd http://www.springframework.org/schema/integration/jdbc http://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc-4.3.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.3.xsd http://www.springframework.org/schema/integration/http http://www.springframework.org/schema/integration/http/spring-integration-http-4.3.xsd http://www.springframework.org/schema/integration/groovy http://www.springframework.org/schema/integration/groovy/spring-integration-groovy-4.3.xsd http://www.springframework.org/schema/integration/scripting http://www.springframework.org/schema/integration/scripting/spring-integration-scripting-4.3.xsd http://www.springframework.org/schema/integration/event http://www.springframework.org/schema/integration/event/spring-integration-event-4.3.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd http://www.springframework.org/schema/integration/amqp http://www.springframework.org/schema/integration/amqp/spring-integration-amqp-4.3.xsd http://www.springframework.org/schema/integration/stream http://www.springframework.org/schema/integration/stream/spring-integration-stream-4.3.xsd">
<int:logging-channel-adapter id="loggingChannel" level="INFO"/>
  <stream:stderr-channel-adapter channel="errorChannel" append-newline="true"/>
  <bean id="errorUnwrapper" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ErrorUnwrapper"/>
  <int:channel id="recoveryChannel"/>
  <int:transformer input-channel="recoveryChannel" output-channel="loggingChannel" expression="'Failure after many attemps for the message :' + payload.failedMessage.payload"/>
<int-file:inbound-channel-adapter id="file-customer-InputChannel-id" directory="C:/Users/Charroux_std/Documents/projet/ExecAndShare/orcha/Orcha/input" channel="customer-InputChannel" prevent-duplicates="true" filename-pattern="orderTV.json" queue-size="20">
    <int:poller fixed-rate="100"/>
  </int-file:inbound-channel-adapter>
  <int-file:file-to-string-transformer input-channel="customer-InputChannel" output-channel="customer-InputChannelTransformer" delete-files="false"/>
  <int:chain input-channel="customer-InputChannelTransformer" output-channel="customer-OutputChannel">
    <int:json-to-object-transformer type="service.order.Order"/>
    <int:header-enricher id="header-enricher-customer-InputChannel-id">
      <int:header name="messageID" expression="headers['id'].toString()"/>
    </int:header-enricher>
  </int:chain>
<int:recipient-list-router id="router-customer-OutputChannel-id" input-channel="customer-OutputChannel">
    <int:recipient channel="customer-OutputChannelRoute1" selector-expression="payload.product.specification == 'TV'"/>
    <int:recipient channel="customer-OutputChannelRoute2" selector-expression="payload.product.specification == 'TV'"/>
    <int:recipient channel="customer-OutputChannelRoute3" selector-expression="payload.product.specification == 'TV'"/>
    <int:recipient channel="loggingChannel"/>
  </int:recipient-list-router>
  <int:channel id="customer-OutputChannelRoute1"/>
  <int:channel id="customer-OutputChannelRoute2"/>
  <int:channel id="customer-OutputChannelRoute3"/>
<int:chain id="service-activator-chain-orderConverterChannel-id" input-channel="customer-OutputChannelRoute1" output-channel="orderConverterServiceAcivatorOutput">
    <int:service-activator id="service-activator-orderConverterChannel-id" expression="@vendorOrderConverter.convert(payload)"/>
  </int:chain>
  <int:transformer id="transformer-orderConverterServiceAcivatorOutput-id" input-channel="orderConverterServiceAcivatorOutput" output-channel="orderConverterAggregatorInput" ref="orderConverterTransformerBean" method="transform"/>
  <bean id="orderConverterTransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ObjectToApplicationTransformer">
    <property name="application" ref="orderConverter"/>
  </bean>
<int:aggregator id="aggregator-orderConverterAggregatorInput-id" input-channel="orderConverterAggregatorInput" output-channel="orderConverterAggregatorInputTransformer" correlation-strategy-expression="headers['messageID']" release-strategy-expression="size()==1 and ( ([0].payload instanceof T(orcha.lang.configuration.Application) AND [0].payload.state==T(orcha.lang.configuration.State).TERMINATED) )"/>
  <int:transformer id="transformer-orderConverterAggregatorInput-id" input-channel="orderConverterAggregatorInputTransformer" output-channel="orderConverterAggregatorInputAggregatorOutput" expression="payload.?[name=='orderConverter']"/>
  <int:transformer id="transformer-orderConverterAggregatorInputAggregatorOutput-id" input-channel="orderConverterAggregatorInputAggregatorOutput" output-channel="orderConverterAggregatorOutputTransformer" ref="orderConverterAggregatorOutputTransformerApplicationToObjectTransformerBean" method="transform"/>
  <bean id="orderConverterAggregatorOutputTransformerApplicationToObjectTransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ApplicationToObjectTransformer"/>
<int:chain id="service-activator-chain-vendor1Channel-id" input-channel="orderConverterAggregatorOutputTransformer" output-channel="vendor1ServiceAcivatorOutput">
    <int:service-activator id="service-activator-vendor1Channel-id">
      <int-script:script lang="js" location="file:src/main/orcha/service/order/vendor1.js"/>
      <int:request-handler-advice-chain>
        <ref bean="eventSourcingAdvice"/>
      </int:request-handler-advice-chain>
    </int:service-activator>
  </int:chain>
  <int:transformer id="transformer-vendor1ServiceAcivatorOutput-id" input-channel="vendor1ServiceAcivatorOutput" output-channel="vendor1vendor2vendor3AggregatorInput" ref="vendor1TransformerBean" method="transform">
    <int:request-handler-advice-chain>
      <ref bean="eventSourcingAdvice"/>
    </int:request-handler-advice-chain>
  </int:transformer>
  <bean id="vendor1TransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ObjectToApplicationTransformer">
    <property name="application" ref="vendor1"/>
  </bean>
<int:chain id="service-activator-chain-vendor2Channel-id" input-channel="customer-OutputChannelRoute2" output-channel="vendor2ServiceAcivatorOutput">
    <int:service-activator id="service-activator-vendor2Channel-id">
      <int-script:script lang="js" location="file:src/main/orcha/service/order/vendor2.js"/>
    </int:service-activator>
  </int:chain>
  <int:transformer id="transformer-vendor2ServiceAcivatorOutput-id" input-channel="vendor2ServiceAcivatorOutput" output-channel="vendor1vendor2vendor3AggregatorInput" ref="vendor2TransformerBean" method="transform"/>
  <bean id="vendor2TransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ObjectToApplicationTransformer">
    <property name="application" ref="vendor2"/>
  </bean>
<int:chain id="service-activator-chain-vendor3Channel-id" input-channel="customer-OutputChannelRoute3" output-channel="vendor3ServiceAcivatorOutput">
    <int:service-activator id="service-activator-vendor3Channel-id">
      <int-script:script lang="js" location="file:src/main/orcha/service/order/vendor3.js"/>
    </int:service-activator>
  </int:chain>
  <int:transformer id="transformer-vendor3ServiceAcivatorOutput-id" input-channel="vendor3ServiceAcivatorOutput" output-channel="vendor1vendor2vendor3AggregatorInput" ref="vendor3TransformerBean" method="transform"/>
  <bean id="vendor3TransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ObjectToApplicationTransformer">
    <property name="application" ref="vendor3"/>
  </bean>
<int:aggregator id="aggregator-vendor1vendor2vendor3AggregatorInput-id" input-channel="vendor1vendor2vendor3AggregatorInput" output-channel="vendor1vendor2vendor3AggregatorInputTransformer" correlation-strategy-expression="headers['messageID']" release-strategy-expression="size()==3 and (( ([0].payload instanceof T(orcha.lang.configuration.Application) AND [0].payload.state==T(orcha.lang.configuration.State).TERMINATED) ) and ( ([1].payload instanceof T(orcha.lang.configuration.Application) AND [1].payload.state==T(orcha.lang.configuration.State).TERMINATED) ) and ( ([2].payload instanceof T(orcha.lang.configuration.Application) AND [2].payload.state==T(orcha.lang.configuration.State).TERMINATED) ))"/>
  <int:transformer id="transformer-vendor1vendor2vendor3AggregatorInput-id" input-channel="vendor1vendor2vendor3AggregatorInputTransformer" output-channel="vendor1vendor2vendor3AggregatorInputAggregatorOutput" expression="payload.?[name=='vendor1' or name=='vendor2' or name=='vendor3']"/>
  <int:transformer id="transformer-vendor1vendor2vendor3AggregatorInputAggregatorOutput-id" input-channel="vendor1vendor2vendor3AggregatorInputAggregatorOutput" output-channel="vendor1vendor2vendor3AggregatorOutputTransformer" ref="vendor1vendor2vendor3AggregatorOutputTransformerApplicationsToObjectsTransformerBean" method="transform"/>
  <bean id="vendor1vendor2vendor3AggregatorOutputTransformerApplicationsToObjectsTransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ApplicationsListToObjectsListTransformer"/>
<int:chain id="service-activator-chain-selectBestVendorChannel-id" input-channel="vendor1vendor2vendor3AggregatorOutputTransformer" output-channel="selectBestVendorServiceAcivatorOutput">
    <int:service-activator id="service-activator-selectBestVendorChannel-id" expression="@vendorComparison.compare(payload)"/>
  </int:chain>
  <int:transformer id="transformer-selectBestVendorServiceAcivatorOutput-id" input-channel="selectBestVendorServiceAcivatorOutput" output-channel="selectBestVendorAggregatorInput" ref="selectBestVendorTransformerBean" method="transform"/>
  <bean id="selectBestVendorTransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ObjectToApplicationTransformer">
    <property name="application" ref="selectBestVendor"/>
  </bean>
<int:recipient-list-router id="router-selectBestVendorAggregatorInput-id" input-channel="selectBestVendorAggregatorInput">
    <int:recipient channel="selectBestVendorAggregatorInputRoute1"/>
    <int:recipient channel="selectBestVendorAggregatorInputRoute2"/>
  </int:recipient-list-router>
<int:aggregator id="aggregator-selectBestVendorAggregatorInputRoute1-id" input-channel="selectBestVendorAggregatorInputRoute1" output-channel="selectBestVendorAggregatorInputRoute1Transformer" correlation-strategy-expression="headers['messageID']" release-strategy-expression="size()==1 and ( ([0].payload instanceof T(orcha.lang.configuration.Application) AND [0].payload.state==T(orcha.lang.configuration.State).TERMINATED)  and  [0].payload.output.value.price&gt;1000 )"/>
  <int:transformer id="transformer-selectBestVendorAggregatorInputRoute1-id" input-channel="selectBestVendorAggregatorInputRoute1Transformer" output-channel="selectBestVendorAggregatorInputRoute1AggregatorOutput" expression="payload.?[name=='selectBestVendor']"/>
  <int:transformer id="transformer-selectBestVendorAggregatorInputRoute1AggregatorOutput-id" input-channel="selectBestVendorAggregatorInputRoute1AggregatorOutput" output-channel="selectBestVendorAggregatorOutputTransformerRoute1" ref="selectBestVendorAggregatorOutputTransformerRoute1ApplicationToObjectTransformerBean" method="transform"/>
  <bean id="selectBestVendorAggregatorOutputTransformerRoute1ApplicationToObjectTransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ApplicationToObjectTransformer"/>
<int:chain input-channel="selectBestVendorAggregatorOutputTransformerRoute1" output-channel="selectBestVendorOutputFileChannelAdapteroutputFile1">
    <int:transformer expression="payload">
      <int:request-handler-advice-chain>
        <ref bean="eventSourcingAdvice"/>
      </int:request-handler-advice-chain>
    </int:transformer>
    <int:object-to-json-transformer/>
  </int:chain>
  <int:channel id="selectBestVendorOutputFileChannelAdapteroutputFile1"/>
  <int-file:outbound-channel-adapter id="file-selectBestVendoroutputFile1Channel-id" channel="selectBestVendorOutputFileChannelAdapteroutputFile1" directory-expression="@outputFile1.output.adapter.directory" filename-generator-expression="@outputFile1.output.adapter.filename" append-new-line="true" mode="REPLACE" auto-create-directory="true" delete-source-files="false"/>
<int:aggregator id="aggregator-selectBestVendorAggregatorInputRoute2-id" input-channel="selectBestVendorAggregatorInputRoute2" output-channel="selectBestVendorAggregatorInputRoute2Transformer" correlation-strategy-expression="headers['messageID']" release-strategy-expression="size()==1 and ( ([0].payload instanceof T(orcha.lang.configuration.Application) AND [0].payload.state==T(orcha.lang.configuration.State).TERMINATED)  and  [0].payload.output.value.price&lt;=1000 )"/>
  <int:transformer id="transformer-selectBestVendorAggregatorInputRoute2-id" input-channel="selectBestVendorAggregatorInputRoute2Transformer" output-channel="selectBestVendorAggregatorInputRoute2AggregatorOutput" expression="payload.?[name=='selectBestVendor']"/>
  <int:transformer id="transformer-selectBestVendorAggregatorInputRoute2AggregatorOutput-id" input-channel="selectBestVendorAggregatorInputRoute2AggregatorOutput" output-channel="selectBestVendorAggregatorOutputTransformerRoute2" ref="selectBestVendorAggregatorOutputTransformerRoute2ApplicationToObjectTransformerBean" method="transform"/>
  <bean id="selectBestVendorAggregatorOutputTransformerRoute2ApplicationToObjectTransformerBean" class="orcha.lang.compiler.referenceimpl.xmlgenerator.impl.ApplicationToObjectTransformer"/>
<int:chain input-channel="selectBestVendorAggregatorOutputTransformerRoute2" output-channel="selectBestVendorOutputFileChannelAdapteroutputFile2">
    <int:object-to-json-transformer/>
  </int:chain>
  <int:channel id="selectBestVendorOutputFileChannelAdapteroutputFile2"/>
  <int-file:outbound-channel-adapter id="file-selectBestVendoroutputFile2Channel-id" channel="selectBestVendorOutputFileChannelAdapteroutputFile2" directory-expression="@outputFile2.output.adapter.directory" filename-generator-expression="@outputFile2.output.adapter.filename" append-new-line="true" mode="REPLACE" auto-create-directory="true" delete-source-files="false"/>
</beans>

